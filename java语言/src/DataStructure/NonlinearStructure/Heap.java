package DataStructure.NonlinearStructure;
/*
* 视频中没有讲到堆，这里我将对堆进行一个理解
* 堆的定义：
* 1、必须是一个完全二叉树
* 2、堆序性： 可以将堆分为两类
*       大根堆：每个父节点要比左右子节点要大
*       小根堆：每个父节点要小于左右子节点
* 一个堆使用一个数组来进行描述
* 因为堆是一个完全二叉树，将树中的每个节点按照满二叉树进行，标注下标
* 这些下面对应数组的下面按层级依次将树的节点存放进数组中，这样就能将一个堆转换成为一个数组了
* 画图可知 当前节点下标为i，左节点的下标为2i+1,右节点的下标为2i+2，这个规律在算法中经常使用
* 但是数组转堆，需要经过堆的基本操作（上虑，下虑），因为数组转堆可能破坏堆的性质
* 上虑：
* 假设给你一颗树
*        1
*      /  \
*     7    6
*    / \  / \
*   4  5  1  2
* 其中破坏堆的性质的节点是根节点，1,按照大根堆；需要将1与左节点和右节点的最大值进行交换，后续操作一样，最后转化成合格的堆
*         7
 *      /  \
 *     5    6
 *    / \  / \
 *   4  1  1  2
 * 以上的操作就是下虑，复杂度为O(logN)
 * 下虑：
 *        7
 *      /  \
 *     5    6
 *    / \  / \
 *   4  1  1  8
 * 只有最后一个节点破坏了堆的性质，8，按照大根堆，需要将这个节点与父节点进行交换，在进行上一步操作，最后转换成一个合格的堆
 *        8
 *      /  \
 *     5    7
 *    / \  / \
 *   4  1  1  6
 * 以上的操作就是上虑，时间复杂度也是O(logN),这个操作主要用于新元素插入到堆中
 *
 * 建堆：
 * 给你一个乱序的数组，该如何建堆？
 * ①自顶向下【对应的操作为上虑】：
 *思路：将数组中的元素依次插入到堆内，插入一个元素后进行一次校验，看是否插入的元素导致堆的性质被破坏，
 * 如果破坏就将该节点进行上虑   复杂度为O(NlogN)
 * ②自下而上【对应的操作为下虑】：
 * 思路：将数组的元素依次插入到堆内，全部插入后，对每一个父节点进行下虑操作，从最后一个父节点开始，时间复杂度为O(N)
 *
 *常见的操作：优先队列、堆排序
 *
* */
public class Heap {

}
